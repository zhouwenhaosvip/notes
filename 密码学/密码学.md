# 密码学

### 一.对称加密

#### 1.定义 

​	用同一个密钥用来加密和解密

​	常见的算法DES，3DES，AES，RC2，RC4，RC5

​	优点：加密计算量小，速度快，适合对大量数据进行加密的场景

#### 2.密钥传输问题/密钥管理问题

​	密钥传输问题：由于对称加密的加密和解密使用的是同一个密钥，所以对称加密的安全性就不仅仅取决于加密算法本身的强度，更取决于密钥是否被安全的保管，因此加密者如何把密钥安全的传递到解密者手里，就成了对称加密面临的关键问题。（比如，我们客户端肯定不能直接存储对称加密的密钥，因为被反编译之后，密钥就泄露了，数据安全性就得不到保障，所以实际中我们一般都是客户端向服务端请求对称加密的密钥，而且密钥还得用非对称加密加密后再传输。

​	随着密钥数量的增多，密钥的管理问题会逐渐显现出来。比如我们在加密用户的信息时，不可能所有用户都用同一个密钥加密解密，这样的话，一旦密钥泄漏，就相当于泄露了所有用户的信息，因此需要为每一个用户单独的生成一个密钥并且管理，这样密钥管理的代价也会非常大。

#### 3.DES/3DES

​	是一种使用密钥加密的块算法。现在认为是一种不安全的加密算法，因为现在已经有用穷举法攻破 DES 密码的报道了。尽管如此，该加密算法还是运用非常普遍，是一种标准的加密算法，标准密钥就是56位。

​	3DES（或称为 Triple DES）是三重数据加密算法（TDEA，Triple Data Encryption Algorithm）块密码的通称。它相当于是对每个数据块应用三次 DES 加密算法。由于计算机运算能力的增强，原版 DES 密码的密钥长度变得容易被暴力破解；3DES 即是设计用来提供一种相对简单的方法，即通过增加 DES 的密钥长度来避免类似的攻击，而不是设计一种全新的块密码算法。

#### 4.AES

​	AES 加密算法采用分组密码体制，每个分组数据的长度为128位16个字节，密钥长度可以是128位16个字节、192位或256位，一共有四种加密模式，我们通常采用需要初始向量 IV 的 CBC 模式，初始向量的长度也是128位16个字节。

##### 4.1分组密码体制

​	AES 采用分组密码体制，即 AES 加密会首先把明文切成一段一段的，而且每段数据的长度要求必须是128位16个字节，如果最后一段不够16个字节了，就需要用 Padding 来把这段数据填满16个字节，然后分别对每段数据进行加密，最后再把每段加密数据拼起来形成最终的密文.

​	padding规则：有三种模式 PKCS5、PKCS7 和NOPADDING

​		PKCS5：是指分组数据缺少几个字节，就在数据的末尾填充几个字节的几。

​		PKCS7 ：是指分组数据缺少几个字节，就在数据的末尾填充几个字节的0。

​		NOPADDING：是指不需要填充，也就是说数据的发送方肯定会保证最后一段数据也正好是16个字节。

##### 4.2初始向量

​	初始向量 IV 的作用是使加密更加安全可靠，我们使用 AES 加密时需要主动提供初始向量，而且只需要提供一个初始向量就够了，后面每段数据的加密向量都是前面一段的密文。初始向量 IV 的长度规定为128位16个字节，初始向量的来源为随机生成。

##### 4.3AES-128

​	密钥的长度为128位，加密轮数为10轮。前九轮一样，最后一轮没有列变换。

​	流程图：

​	128位密钥也是用字节为单位的矩阵表示，矩阵的每一列被称为1个32位比特字。通过密钥编排函数该密钥矩阵被扩展成一个44个字组成的序列W[0],W[1], … ,W[43],该序列的前4个元素W[0],W[1],W[2],W[3]是原始密钥，用于加密运算中的初始密钥加（下面介绍）;后面40个字分为10组，每组4个字（128比特）分别用于10轮加密运算中的轮密钥加，如下图所示：

<img src="C:\Users\GongYutong\Desktop\笔记\密码学\AES密钥编排图.png" style="zoom:50%;" />

<img src="C:\Users\GongYutong\Desktop\笔记\密码学\AES实现流程图.png" style="zoom:50%;" />

​	实现：

​	上图展示了AES解密过程，解密过程仍为10轮，每一轮的操作是加密操作的逆操作。由于AES的4个轮操作都是可逆的，因此，解密操作的一轮就是顺序执行逆行移位、逆字节代换、轮密钥加和逆列混合。同加密操作类似，最后一轮不执行逆列混合，在第1轮解密之前，要执行1次密钥加操作。

```tex
1.字节代换

2.行移位

3.列混合

4.轮密钥加

```

​	



### 二.非对称加密

#### 1.定义

​	非对称加密需要两个密钥：公钥和私钥 。公钥和私钥是一对，如果用公钥对数据加密，那么只能用对应的私钥解密。如果用私钥对数据加密，只能用对应的公钥进行解密。因为加密和解密用的是不同的密钥，所以称为非对称加密。

​	非对称加密算法的保密性好，它消除了最终用户交换密钥的需要。但是加解密速度要远远慢于对称加密。

#### 2.RSA

##### 2.1 算法解释

​	算法本身基于一个简单的数论知识：给出两个素数，很容易将它们相乘，然而给出它们的乘积，想得到这两个素数就显得尤为困难。如果能够解决大整数（比如几百位的整数）分解的快速方法，那么 **RSA** 算法将轻易被破解。

##### 2.2 公钥和私钥的生成

​		1）准备两个非常大的素数p和q（转换成二进制后 个二进制位或者更多，位数越多越难破解）；
    2）利用字符串模拟计算大素数p和q的乘积n=pq ；
    3）同样方法计算 ，m=(p-1)*(q-1)这里的m为 n的欧拉函数；
    4）找到一个数 e(1<e<m)，满足gcd(m,e) = 1 （即 e和 m互素）；
    5）计算 e在模 m域上的逆元d （即满足ed mod m = 1）；
    6）至此，公钥和私钥生成完毕： (n,e)为公钥， (m,d)为私钥；

注：1.互素：gcd(m,e)=1，意思是m和e的最大公约数为1

​		2.mod：取余的意思



##### 2.3 RSA加密

​	对于明文x，用公钥(n,e)对x加密的过程，就是将x转换成数字（字符串的话取其 ASCII码或者 unicode 值），然后通过幂取模计算出y，其中y就是密文；

```tex
y = x^e mod n;
```



##### 2.4 RSA 解密

​	对于密文y，用私钥(m,d)对y进行解密的过程和加密类似，同样是计算幂取模；

```tex
x = y^d mod m;
```



#### 3.椭圆曲线加密算法

##### 3.1安全性来源：

给定：Q=kP，已知点 P和 Q，求标量 k在计算上不可行。

椭圆曲线离散对数问题（ECDLP）

给定：椭圆曲线：𝐸  、基点 ：𝐺 、 公钥点：Q 、 Q=kG 

​		   求私钥 𝑘

| 问题            | 算法           | 复杂度        |
| --------------- | -------------- | ------------- |
| 计算 (P = kG)   | Double-and-Add | (O(\log k))   |
| 求 (k) from (P) | Pollard Rho    | (O(\sqrt{k})) |



##### 3.2椭圆曲线上的“加法”

点倍加 P+P：

1. 作点 P处的切线
2. 与曲线交于 R
3. 取对称点 → 2P



##### 3.3Double-and-Add

假设：

- k=13=(1101)2
- 要算 13G

初始化：

```
P = O
```

------

bit 1（1）：

```
P = 2O = O
P = O + G = G
```

------

bit 1（1）：

```
P = 2G
P = 2G + G = 3G
```

------

bit 0（0）：

```
P = 2 · 3G = 6G
```

------

bit 1（1）：

```
P = 2 · 6G = 12G
P = 12G + G = 13G
```

对一个 n-bit 标量 k：

- 倍点：**n 次**
- 加点：平均 **n/2 次**

总操作≈1.5n



##### 3.4侧信道攻击

密码学通常假设：

> 攻击者只能看到：

- 输入
- 输出

但现实中，攻击者还能看到：

| 泄露维度 | 举例            |
| -------- | --------------- |
| 时间     | 运算快慢        |
| 功耗     | 用电曲线        |
| 电磁     | EM 辐射         |
| Cache    | Cache 命中/失效 |
| 分支     | if / else 行为  |
| 错误     | 报错信息        |

👉 **这些“旁边的信息”就是侧信道**

Double-and-Add 伪代码：

```
for bit in k:
    P = 2P
    if bit == 1:
        P = P + G
```

⚠️ 注意这一行：

```
if bit == 1:
```

这意味着：

| 私钥 bit | 执行的操作  |
| -------- | ----------- |
| 0        | 只倍点      |
| 1        | 倍点 + 加点 |

------

攻击者能看到什么？

1️⃣ 时间不同

- 倍点：需要 T₁ 时间
- 倍点 + 加点：需要 T₁ + T₂ 时间

👉 **bit = 1 的轮次更慢**

------

2️⃣ 功耗不同

- 加点需要更多乘法
- 功耗曲线出现“尖峰”

👉 **bit = 1 有明显特征**



最简单的侧信道攻击：时间攻击（Timing Attack）

攻击流程

1. 攻击者反复触发签名 / 解密
2. 记录每次总耗时
3. 分析每一轮的时间差
4. 推断哪些 bit 是 1



##### 3.5Montgomery Ladder

我们还是用： k=13=(1101)2

------

初始化

```
R0 = 0G
R1 = 1G
```

------

bit = 1

```
R0 = R0 + R1 = 1G
R1 = 2R1     = 2G
```

------

bit = 1

```
R0 = R0 + R1 = 3G
R1 = 2R1     = 4G
```

------

bit = 0

```
R1 = R0 + R1 = 7G
R0 = 2R0     = 6G
```

------

bit = 1

```
R0 = R0 + R1 = 13G
R1 = 2R1     = 14G
```

------

结束

```
R0 = 13G
```



##### 3.6例子：利用ECC加密数据7

1. 生成密钥对

- **私钥** d：随机选取的一个小于 *n* 的正整数。
- **公钥** Q = dG：通过将基点 *G* 与私钥 d 相乘得到的结果点。

2. 加密过程

​	假设我们要加密的消息是一个整数 *m*=7。加密步骤如下：

1. 发送者选择一个随机数 *k*，并计算临时密钥 P  = kG。
2. 使用 k 和接收者的公钥 Q 计算共享点 C1 = kQ。
3. 将消息 *m* 映射到椭圆曲线上的一个点 *M*（这个映射的具体方法取决于所选的方案）。然后计算 *C*2=*M*+*C*1。
4. 加密后的结果是 (*P*,*C*2)。

3. 解密过程

​	接收者使用自己的私钥 *d* 来恢复原始信息：

1. 接收者收到 (*P*,*C*2)，并计算共享点 *C*1′=*dP*。
2. 从 *C*2 中减去 *C*1′ 得到 *M*=*C*2−*C*1′。
3. 最后，将点 *M* 反向映射回原来的整数值 *m*。









### 三.数字签名

#### 1.定义

数字签名的工作原理：
		生成摘要：首先，对原始数据进行哈希运算，生成一个固定长度的摘要。这个摘要是数据的唯一表示，任何对数据的修改都会导致摘							要的变化。
		私钥加密：然后，使用发送者的私钥对这个摘要进行加密，生成数字签名。由于只有发送者拥有私钥，因此只有发送者可以生成这个							签名。
		附加签名：将数字签名附加到原始数据上，一起发送给接收者。
验证数字签名：
		公钥解密：接收者使用发送者的公钥对数字签名进行解密，得到摘要1。由于公钥是公开的，任何人都可以进行解密操作。
		生成摘要：接收者对接收到的原始数据进行哈希运算，生成摘要2。
		对比摘要：比较摘要1和摘要2，如果两者一致，则说明数据未被篡改，且确实是由发送者发出的。

