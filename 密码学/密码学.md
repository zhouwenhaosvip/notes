# 密码学

### 一.对称加密

#### 1.定义 

​	用同一个密钥用来加密和解密

​	常见的算法DES，3DES，AES，RC2，RC4，RC5

​	优点：加密计算量小，速度快，适合对大量数据进行加密的场景

#### 2.密钥传输问题/密钥管理问题

​	密钥传输问题：由于对称加密的加密和解密使用的是同一个密钥，所以对称加密的安全性就不仅仅取决于加密算法本身的强度，更取决于密钥是否被安全的保管，因此加密者如何把密钥安全的传递到解密者手里，就成了对称加密面临的关键问题。（比如，我们客户端肯定不能直接存储对称加密的密钥，因为被反编译之后，密钥就泄露了，数据安全性就得不到保障，所以实际中我们一般都是客户端向服务端请求对称加密的密钥，而且密钥还得用非对称加密加密后再传输。

​	随着密钥数量的增多，密钥的管理问题会逐渐显现出来。比如我们在加密用户的信息时，不可能所有用户都用同一个密钥加密解密，这样的话，一旦密钥泄漏，就相当于泄露了所有用户的信息，因此需要为每一个用户单独的生成一个密钥并且管理，这样密钥管理的代价也会非常大。

#### 3.DES/3DES

​	是一种使用密钥加密的块算法。现在认为是一种不安全的加密算法，因为现在已经有用穷举法攻破 DES 密码的报道了。尽管如此，该加密算法还是运用非常普遍，是一种标准的加密算法，标准密钥就是56位。

​	3DES（或称为 Triple DES）是三重数据加密算法（TDEA，Triple Data Encryption Algorithm）块密码的通称。它相当于是对每个数据块应用三次 DES 加密算法。由于计算机运算能力的增强，原版 DES 密码的密钥长度变得容易被暴力破解；3DES 即是设计用来提供一种相对简单的方法，即通过增加 DES 的密钥长度来避免类似的攻击，而不是设计一种全新的块密码算法。

#### 4.AES

​	AES 加密算法采用分组密码体制，每个分组数据的长度为128位16个字节，密钥长度可以是128位16个字节、192位或256位，一共有四种加密模式，我们通常采用需要初始向量 IV 的 CBC 模式，初始向量的长度也是128位16个字节。

##### 4.1分组密码体制

​	AES 采用分组密码体制，即 AES 加密会首先把明文切成一段一段的，而且每段数据的长度要求必须是128位16个字节，如果最后一段不够16个字节了，就需要用 Padding 来把这段数据填满16个字节，然后分别对每段数据进行加密，最后再把每段加密数据拼起来形成最终的密文.

​	padding规则：有三种模式 PKCS5、PKCS7 和NOPADDING

​		PKCS5：是指分组数据缺少几个字节，就在数据的末尾填充几个字节的几。

​		PKCS7 ：是指分组数据缺少几个字节，就在数据的末尾填充几个字节的0。

​		NOPADDING：是指不需要填充，也就是说数据的发送方肯定会保证最后一段数据也正好是16个字节。

##### 4.2初始向量

​	初始向量 IV 的作用是使加密更加安全可靠，我们使用 AES 加密时需要主动提供初始向量，而且只需要提供一个初始向量就够了，后面每段数据的加密向量都是前面一段的密文。初始向量 IV 的长度规定为128位16个字节，初始向量的来源为随机生成。

##### 4.3AES-128

​	密钥的长度为128位，加密轮数为10轮。前九轮一样，最后一轮没有列变换。

​	流程图：

​	128位密钥也是用字节为单位的矩阵表示，矩阵的每一列被称为1个32位比特字。通过密钥编排函数该密钥矩阵被扩展成一个44个字组成的序列W[0],W[1], … ,W[43],该序列的前4个元素W[0],W[1],W[2],W[3]是原始密钥，用于加密运算中的初始密钥加（下面介绍）;后面40个字分为10组，每组4个字（128比特）分别用于10轮加密运算中的轮密钥加，如下图所示：

<img src="C:\Users\GongYutong\Desktop\笔记\密码学\AES密钥编排图.png" style="zoom:50%;" />

<img src="C:\Users\GongYutong\Desktop\笔记\密码学\AES实现流程图.png" style="zoom:50%;" />

​	实现：

​	上图展示了AES解密过程，解密过程仍为10轮，每一轮的操作是加密操作的逆操作。由于AES的4个轮操作都是可逆的，因此，解密操作的一轮就是顺序执行逆行移位、逆字节代换、轮密钥加和逆列混合。同加密操作类似，最后一轮不执行逆列混合，在第1轮解密之前，要执行1次密钥加操作。

```tex
1.字节代换

2.行移位

3.列混合

4.轮密钥加

```

​	



### 二.非对称加密

#### 1.定义

​	非对称加密需要两个密钥：公钥和私钥 。公钥和私钥是一对，如果用公钥对数据加密，那么只能用对应的私钥解密。如果用私钥对数据加密，只能用对应的公钥进行解密。因为加密和解密用的是不同的密钥，所以称为非对称加密。

​	非对称加密算法的保密性好，它消除了最终用户交换密钥的需要。但是加解密速度要远远慢于对称加密。

#### 2.RSA

##### 2.1 算法解释

​	算法本身基于一个简单的数论知识：给出两个素数，很容易将它们相乘，然而给出它们的乘积，想得到这两个素数就显得尤为困难。如果能够解决大整数（比如几百位的整数）分解的快速方法，那么 **RSA** 算法将轻易被破解。

##### 2.2 公钥和私钥的生成

​		1）准备两个非常大的素数p和q（转换成二进制后 个二进制位或者更多，位数越多越难破解）；
    2）利用字符串模拟计算大素数p和q的乘积n=pq ；
    3）同样方法计算 ，m=(p-1)*(q-1)这里的m为 n的欧拉函数；
    4）找到一个数 e(1<e<m)，满足gcd(m,e) = 1 （即 e和 m互素）；
    5）计算 e在模 m域上的逆元d （即满足ed mod m = 1）；
    6）至此，公钥和私钥生成完毕： (n,e)为公钥， (m,d)为私钥；

注：1.互素：gcd(m,e)=1，意思是m和e的最大公约数为1

​		2.mod：取余的意思



##### 2.3 RSA加密

​	对于明文x，用公钥(n,e)对x加密的过程，就是将x转换成数字（字符串的话取其 ASCII码或者 unicode 值），然后通过幂取模计算出y，其中y就是密文；

```tex
y = x^e mod n;
```



##### 2.4 RSA 解密

​	对于密文y，用私钥(m,d)对y进行解密的过程和加密类似，同样是计算幂取模；

```tex
x = y^d mod m;
```



##### 2.5 C语言实现RSA

```c
#include <stdio.h>
#include <stdlib.h>
#include <time.h>
#include <string.h>

#define ACCURACY 5
#define SINGLE_MAX 10000
#define EXPONENT_MAX 1000
#define BUF_SIZE 1024

/**
 * Computes a^b mod c
 */
int modpow(long long a, long long b, int c) {
    int res = 1;
    while(b > 0) {
        /* Need long multiplication else this will overflow... */
        if(b & 1) {
            res = (res * a) % c;
        }
        b = b >> 1;
        a = (a * a) % c; /* Same deal here */
    }
    return res;
}

/**
 * Computes the Jacobi symbol, (a, n)
 */
int jacobi(int a, int n) {
    int twos, temp;
    int mult = 1;
    while(a > 1 && a != n) {
        a = a % n;
        if(a <= 1 || a == n) break;
        twos = 0;
        while(a % 2 == 0 && ++twos) a /= 2; /* Factor out multiples of 2 */
        if(twos > 0 && twos % 2 == 1) mult *= (n % 8 == 1 || n % 8 == 7) * 2 - 1;
        if(a <= 1 || a == n) break;
        if(n % 4 != 1 && a % 4 != 1) mult *= -1; /* Coefficient for flipping */
        temp = a;
        a = n;
        n = temp;
    }
    if(a == 0) return 0;
    else if(a == 1) return mult;
    else return 0; /* a == n => gcd(a, n) != 1 */
}

/**
 * Check whether a is a Euler witness for n
 */
int solovayPrime(int a, int n) {
    int x = jacobi(a, n);
    if(x == -1) x = n - 1;
    return x != 0 && modpow(a, (n - 1)/2, n) == x;
}

/**
 * Test if n is probably prime, using accuracy of k (k solovay tests)
 */
int probablePrime(int n, int k) {
    if(n == 2) return 1;
    else if(n % 2 == 0 || n == 1) return 0;
    while(k-- > 0) {
        if(!solovayPrime(rand() % (n - 2) + 2, n)) return 0;
    }
    return 1;
}

/**
 * Find a random (probable) prime between 3 and n - 1, this distribution is
 * nowhere near uniform, see prime gaps
 */
int randPrime(int n) {
    int prime = rand() % n;
    n += n % 2; /* n needs to be even so modulo wrapping preserves oddness */
    prime += 1 - prime % 2;
    while(1) {
        if(probablePrime(prime, ACCURACY)) return prime;
        prime = (prime + 2) % n;
    }
}

/**
 * Compute gcd(a, b)
 */
int gcd(int a, int b) {
    int temp;
    while(b != 0) {
        temp = b;
        b = a % b;
        a = temp;
    }
    return a;
}

/**
 * Find a random exponent x between 3 and n - 1 such that gcd(x, phi) = 1,
 * this distribution is similarly nowhere near uniform
 */
int randExponent(int phi, int n) {
    int e = rand() % n;
    while(1) {
        if(gcd(e, phi) == 1) return e;
        e = (e + 1) % n;
        if(e <= 2) e = 3;
    }
}

/**
 * Compute n^-1 mod m by extended euclidian method
 */
int inverse(int n, int modulus) {
    int a = n, b = modulus;
    int x = 0, y = 1, x0 = 1, y0 = 0, q, temp;
    while(b != 0) {
        q = a / b;
        temp = a % b;
        a = b;
        b = temp;
        temp = x; x = x0 - q * x; x0 = temp;
        temp = y; y = y0 - q * y; y0 = temp;
    }
    if(x0 < 0) x0 += modulus;
    return x0;
}

/**
 * Read the file fd into an array of bytes ready for encryption.
 * The array will be padded with zeros until it divides the number of
 * bytes encrypted per block. Returns the number of bytes read.
 */
int readFile(FILE* fd, char** buffer, int bytes) {
    int len = 0, cap = BUF_SIZE, r;
    char buf[BUF_SIZE];
    *buffer = malloc(BUF_SIZE * sizeof(char));
    while((r = fread(buf, sizeof(char), BUF_SIZE, fd)) > 0) {
        if(len + r >= cap) {
            cap *= 2;
            *buffer = realloc(*buffer, cap);
        }
        memcpy(&(*buffer)[len], buf, r);
        len += r;
    }
    /* Pad the last block with zeros to signal end of cryptogram. An additional block is added if there is no room */
    if(len + bytes - len % bytes > cap) *buffer = realloc(*buffer, len + bytes - len % bytes);
    do {
        (*buffer)[len] = '\0';
        len++;
    }
    while(len % bytes != 0);
    return len;
}

/**
 * Encode the message m using public exponent and modulus, c = m^e mod n
 */
int encode(int m, int e, int n) {
    return modpow(m, e, n);
}

/**
 * Decode cryptogram c using private exponent and public modulus, m = c^d mod n
 */
int decode(int c, int d, int n) {
    return modpow(c, d, n);
}

/**
 * Encode the message of given length, using the public key (exponent, modulus)
 * The resulting array will be of size len/bytes, each index being the encryption
 * of "bytes" consecutive characters, given by m = (m1 + m2*128 + m3*128^2 + ..),
 * encoded = m^exponent mod modulus
 */
int* encodeMessage(int len, int bytes, char* message, int exponent, int modulus) {
    int *encoded = malloc((len/bytes) * sizeof(int));
    int x, i, j;
    for(i = 0; i < len; i += bytes) {
        x = 0;
        for(j = 0; j < bytes; j++) x += message[i + j] * (1 << (7 * j));
        encoded[i/bytes] = encode(x, exponent, modulus);
#ifndef MEASURE
        printf("%d ", encoded[i/bytes]);
#endif
    }
    return encoded;
}

/**
 * Decode the cryptogram of given length, using the private key (exponent, modulus)
 * Each encrypted packet should represent "bytes" characters as per encodeMessage.
 * The returned message will be of size len * bytes.
 */
int* decodeMessage(int len, int bytes, int* cryptogram, int exponent, int modulus) {
    int *decoded = malloc(len * bytes * sizeof(int));
    int x, i, j;
    for(i = 0; i < len; i++) {
        x = decode(cryptogram[i], exponent, modulus);
        for(j = 0; j < bytes; j++) {
            decoded[i*bytes + j] = (x >> (7 * j)) % 128;
#ifndef MEASURE
            if(decoded[i*bytes + j] != '\0') printf("%c", decoded[i*bytes + j]);
#endif
        }
    }
    return decoded;
}

/**
 * Main method to demostrate the system. Sets up primes p, q, and proceeds to encode and
 * decode the message given in "text.txt"
 */
int main(void) {
    int p, q, n, phi, e, d, bytes, len;
    int *encoded, *decoded;
    char *buffer;
    FILE *f;
    srand(time(NULL));
    while(1) {
        p = randPrime(SINGLE_MAX);
        printf("Got first prime factor, p = %d ... ", p);
        getchar();

        q = randPrime(SINGLE_MAX);
        printf("Got second prime factor, q = %d ... ", q);
        getchar();

        n = p * q;
        printf("Got modulus, n = pq = %d ... ", n);
        if(n < 128) {
            printf("Modulus is less than 128, cannot encode single bytes. Trying again ... ");
            getchar();
        }
        else break;
    }
    if(n >> 21) bytes = 3;
    else if(n >> 14) bytes = 2;
    else bytes = 1;
    getchar();

    phi = (p - 1) * (q - 1);
    printf("Got totient, phi = %d ... ", phi);
    getchar();

    e = randExponent(phi, EXPONENT_MAX);
    printf("Chose public exponent, e = %d\nPublic key is (%d, %d) ... ", e, e, n);
    getchar();

    d = inverse(e, phi);
    printf("Calculated private exponent, d = %d\nPrivate key is (%d, %d) ... ", d, d, n);
    getchar();

    printf("Opening file \"text.txt\" for reading\n");
    f = fopen("D:\\project\\clion\\Demo1\\text.txt", "r");
    if(f == NULL) {
        printf("Failed to open file \"text.txt\". Does it exist?\n");
        return EXIT_FAILURE;
    }
    len = readFile(f, &buffer, bytes); /* len will be a multiple of bytes, to send whole chunks */
    fclose(f);

    printf("File \"text.txt\" read successfully, %d bytes read. Encoding byte stream in chunks of %d bytes ... ", len, bytes);
    getchar();
    encoded = encodeMessage(len, bytes, buffer, e, n);
    printf("\nEncoding finished successfully ... ");
    getchar();


    printf("Decoding encoded message ... ");
    getchar();
    decoded = decodeMessage(len/bytes, bytes, encoded, d, n);


    printf("\nFinished RSA demonstration!\n");

    free(encoded);
    free(decoded);
    free(buffer);
    return EXIT_SUCCESS;
}
```







### 三.数字签名

#### 1.定义

数字签名的工作原理：
		生成摘要：首先，对原始数据进行哈希运算，生成一个固定长度的摘要。这个摘要是数据的唯一表示，任何对数据的修改都会导致摘							要的变化。
		私钥加密：然后，使用发送者的私钥对这个摘要进行加密，生成数字签名。由于只有发送者拥有私钥，因此只有发送者可以生成这个							签名。
		附加签名：将数字签名附加到原始数据上，一起发送给接收者。
验证数字签名：
		公钥解密：接收者使用发送者的公钥对数字签名进行解密，得到摘要1。由于公钥是公开的，任何人都可以进行解密操作。
		生成摘要：接收者对接收到的原始数据进行哈希运算，生成摘要2。
		对比摘要：比较摘要1和摘要2，如果两者一致，则说明数据未被篡改，且确实是由发送者发出的。

